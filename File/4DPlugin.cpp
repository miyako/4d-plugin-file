/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : File
 #	author : miyako
 #	2015/11/01
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"
#include <sstream>

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- File

		case 1 :
			FILE_Get_id(pResult, pParams);
			break;

		case 2 :
			FILE_Get_path(pResult, pParams);
			break;

	}
}

// ------------------------------------- File -------------------------------------

#if VERSIONWIN

int pathResolveRefID(C_TEXT &path, C_TEXT &volumeID, C_TEXT &fileID)
{
	int err = 0;
	wchar_t buf[MAX_PATH];
	std::vector<std::wstring>volumes;
	HANDLE hFirstVolume;
	hFirstVolume = FindFirstVolume(buf, MAX_PATH);
	if (hFirstVolume != INVALID_HANDLE_VALUE)
	{
		std::wstring volume = (const wchar_t *)&buf[0];
		volumes.push_back(volume);
		memset(&buf[0], 0x00, sizeof(wchar_t) * MAX_PATH);

		while(FindNextVolume(hFirstVolume, buf, MAX_PATH))
		{
			std::wstring volume = (const wchar_t *)&buf[0];
			volumes.push_back(volume);
			memset(&buf[0], 0x00, sizeof(wchar_t) * MAX_PATH);
		}
		FindVolumeClose(hFirstVolume);
	}

	DWORD volumeSerialNumber = _wtoi((const wchar_t *)volumeID.getUTF16StringPtr());
	unsigned __int64 _fileNumber = _wcstoui64((const wchar_t *)fileID.getUTF16StringPtr(), NULL, 10);

	LARGE_INTEGER fileNumber;
	fileNumber.HighPart = _fileNumber >> 32;
	fileNumber.LowPart = _fileNumber & 0x00000000FFFFFFFF;

	for (std::vector<std::wstring>::iterator it = volumes.begin(); it != volumes.end(); ++it)
	{
		std::wstring volume = *it;
		DWORD _volumeSerialNumber;
			if (GetVolumeInformation(volume.c_str(),
				NULL,
				0,
				&_volumeSerialNumber,
				NULL,
				NULL,
				NULL,
				0
			)) 
			{
				if (volumeSerialNumber == _volumeSerialNumber) {
					HANDLE hVolume = CreateFile((LPCTSTR)volume.substr(0, volume.length() - 1).c_str(),
						READ_CONTROL,
						0,
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
						NULL);
					if (hVolume != INVALID_HANDLE_VALUE)
					{
						FILE_ID_DESCRIPTOR fd;
						fd.dwSize = sizeof(FILE_ID_DESCRIPTOR);
						fd.Type = FileIdType;
						fd.FileId = fileNumber;

						HANDLE hFile = OpenFileById(hVolume,
							&fd, 
							FILE_GENERIC_READ,
							0,
							NULL, 
							0);
						if (hFile != INVALID_HANDLE_VALUE)
						{
							DWORD len = GetFinalPathNameByHandle(hFile, NULL, 0, 0);
							if (len)
							{
								std::vector<wchar_t>buf(len+1);
								if (GetFinalPathNameByHandle(hFile, &buf[0], len, 0))
								{
									std::wstring _path = (const wchar_t *)&buf[0];
									BY_HANDLE_FILE_INFORMATION info;
									if (GetFileInformationByHandle(hFile, &info))
									{
										if ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
										{
											_path += L"\\";
										}
									}
									path.setUTF16String((const PA_Unichar *)_path.substr(4).c_str(), _path.size());
								}
								else {
									err = -1;
								}
							}
							else {
								err = GetLastError();
							}
							CloseHandle(hFile);
						}
						CloseHandle(hVolume);
					}
					break;
				}
		}
		{

		}
	}
	return err;
}

int pathGetRefID(C_TEXT &path, C_TEXT &volumeID, C_TEXT &fileID)
{
	int err = 0;
	std::wstring _path = L"\\\\?\\";
	_path += (wchar_t *)path.getUTF16StringPtr();
	
	HANDLE hFile = CreateFile((LPCTSTR)_path.c_str(),
														GENERIC_READ,
														0,
														NULL,
														OPEN_EXISTING,
														FILE_ATTRIBUTE_NORMAL,
														NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (_path.back() == '\\')
		{
			_path = _path.substr(0, _path.length()-1);
		}
		hFile = CreateFile((LPCTSTR)_path.c_str(),
			READ_CONTROL,
			0,
			NULL,
			OPEN_EXISTING,
			FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
			NULL);
	}
	if(hFile != INVALID_HANDLE_VALUE)
	{
		BY_HANDLE_FILE_INFORMATION info;
		if(GetFileInformationByHandle(hFile, &info))
		{
			DWORD _volumeID = info.dwVolumeSerialNumber;
			unsigned __int64 _fileID = info.nFileIndexHigh;
			_fileID = (_fileID << 32) | info.nFileIndexLow;
			std::stringstream v;
			std::stringstream f;
			v << _volumeID;
			f << _fileID;
			std::string vv = v.str();
			std::string ff = f.str();
			volumeID.setUTF8String((const uint8_t *)vv.c_str(), vv.size());
			fileID.setUTF8String((const uint8_t *)ff.c_str(), ff.size());
		}else{
			err = -1;
		}
		CloseHandle(hFile);
	}else{
		err = GetLastError();
	}
	return err;
}
#endif

#if VERSIONMAC
int pathGetFSRefID(C_TEXT &path, FSVolumeRefNum *volumeID, UInt32 *fileID)
{
    int err = -1;
    NSString *_path = path.copyPath();
    FSRef fSRef;
    NSURL *url = [[NSURL alloc]initFileURLWithPath:_path];
    if(url)
    {
        if(CFURLGetFSRef((CFURLRef)url, &fSRef))
        {
            FSCatalogInfo catalogInfo;
            err = FSGetCatalogInfo(&fSRef,
            kFSCatInfoNodeID|kFSCatInfoVolume,
            &catalogInfo,
            NULL, NULL, NULL);
            if(err == noErr)
            {
                *volumeID = catalogInfo.volume;
                *fileID = catalogInfo.nodeID;
                err = 0;
            }
        }
        [url release];
    }
    [_path release];
    return err;
}
#endif

#if VERSIONMAC
int pathGetFileSystemNumbers(C_TEXT &path, NSInteger *volumeID, NSUInteger *fileID)
{
    int err = -1;
    NSFileManager * defaultManager = [NSFileManager defaultManager];
    NSString *_path = path.copyPath();
    NSError *error;
    NSDictionary *attributes;
    attributes = [defaultManager attributesOfFileSystemForPath:_path error:&error];
    if(attributes)
    {
        NSNumber *fileSystemNumber = [attributes objectForKey:NSFileSystemNumber];
        attributes = [defaultManager attributesOfItemAtPath:_path error:&error];
        if(attributes)
        {
            NSNumber *fileNumber = [attributes objectForKey:NSFileSystemFileNumber];
            *volumeID = [fileSystemNumber longValue];
            *fileID = [fileNumber unsignedLongValue];
            err = 0;
            
        }else{
            err = [error code];
        }
    }else{
        err = [error code];
    }
    [_path release];
    return err;
}
#endif

#if VERSIONMAC
NSString *pathGetReferenceUrl(C_TEXT &path)
{
    NSString *referenceUrl = @"";
    NSString *_path = path.copyPath();
    NSURL *url = [[NSURL alloc]initFileURLWithPath:_path];
    if(url)
    {
        CFErrorRef error;
        CFURLRef _url = CFURLCreateFileReferenceURL(kCFAllocatorDefault, (CFURLRef)url, &error);
        if(_url)
        {
            referenceUrl = [(NSURL *)_url absoluteString];
            [(NSURL *)_url release];
        }
        [url release];
    }
    return referenceUrl;
}
#endif

#if VERSIONMAC
NSString *getFileSystemPath(C_TEXT &fileSystemNumber)
{
    NSString *fileSystemPath = @"";
    NSString *_fileSystemNumber = fileSystemNumber.copyUTF16String();
    NSNumber *__fileSystemNumber = [NSNumber numberWithUnsignedLong:[_fileSystemNumber longLongValue]];
    NSError *error;
    NSFileManager * defaultManager = [NSFileManager defaultManager];
    NSArray *volumeUrls = [defaultManager mountedVolumeURLsIncludingResourceValuesForKeys:nil options:0];
    if(volumeUrls)
    {
        for(NSUInteger i = 0; i < [volumeUrls count];++i)
        {
            NSString *path = [[volumeUrls objectAtIndex:i]path];
            NSDictionary *attributes = [defaultManager attributesOfFileSystemForPath:path error:&error];
            if(attributes)
            {
                if([__fileSystemNumber isEqualToNumber:[attributes objectForKey:NSFileSystemNumber]])
                {
                    fileSystemPath = path;
                    break;
                }
            }
        }
    }
    [_fileSystemNumber release];
    return fileSystemPath;
}
#endif

#if VERSIONMAC
int pathResolveFSRefID(C_TEXT &path, C_TEXT &volumeID, C_TEXT &fileID)
{
    int err = -1;
    NSString *_volumeID = volumeID.copyUTF16String();
    NSString *_fileID = fileID.copyUTF16String();
    FSVolumeRefNum __volumeID = [[NSNumber numberWithInteger:[_volumeID integerValue]]shortValue];
    UInt32 __fileID = [[NSNumber numberWithUnsignedLong:[_fileID longLongValue]]unsignedIntValue];
    FSRef fSRef;
    if(!FSResolveNodeID(__volumeID, __fileID, &fSRef))
    {
        NSURL *url = (NSURL *)CFURLCreateFromFSRef(kCFAllocatorDefault, &fSRef);
        if(url)
        {
					NSString *_path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
					if(CFURLHasDirectoryPath((CFURLRef)url))
					 {
						path.setUTF16String([NSString stringWithFormat:@"%@:", _path]);
					 }else{
						path.setUTF16String(_path);
					 }
					
					 [_path release];
            err = 0;
        }
    }
    [_volumeID release];
    [_fileID release];
    return err;
}
#endif

void FILE_Get_id(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

#if VERSIONMAC
    UInt32 fileID;
    FSVolumeRefNum volumeID;
    int err = pathGetFSRefID(Param1, &volumeID, &fileID);
    if(err)
    {
        returnValue.setIntValue(err);
    }else
    {
        Param2.setUTF16String([NSString stringWithFormat:@"%hd", volumeID]);
        Param3.setUTF16String([NSString stringWithFormat:@"%u", (unsigned int)fileID]);
    }
#else
	returnValue.setIntValue(pathGetRefID(Param1, Param2, Param3));
#endif

	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

void FILE_Get_path(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;

	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

#if VERSIONMAC
	returnValue.setIntValue(pathResolveFSRefID(Param1, Param2, Param3));
#else
	returnValue.setIntValue(pathResolveRefID(Param1, Param2, Param3));
#endif

	Param1.toParamAtIndex(pParams, 1);
	returnValue.setReturn(pResult);
}

